# Практическое задание по формальным языкам №2

## Описание задачи
Написать алгоритмы парсинга в контекстно-свободных грамматиках, проверяющие _выводимость_ произвольного слова.
Выбранные алгоритмы:
1. Алгоритм Эрли
2. Алгоритм LR(1)

## Используемые технологии

* Linux 5.16.0-051600-generic (Linux Mint)
* C++ (компилятор Clang 12.0.0)
* CMake 3.16.3
* Утилиты LLVM (llvm-profdata, llvm-cov, asan)
* Google Test

#### Установка Google Test
Google Test должен быть установлен на вашем компьютере для того, чтобы проект можно было собрать заново. Необходимо выполнить следующие шаги:
```bash
sudo apt-get install libgtest-dev
cd /usr/src/gtest
sudo cmake CMakeLists.txt
sudo make
cd lib
sudo cp ./*.a /usr/lib
```

## Решение задачи
1. Разработана небольшая библиотека для работы с грамматиками и функция для построения грамматики по простому описанию. 
2. Реализован алгоритм Эрли в виде функции, принимающей грамматику и слово и сообщающей, выводится ли слово или нет.
3. Реализован парсер LR(1) в виде класса с аналогичным функционалом. Так как в алгоритме Эрли нет предподсчета, его не было смысла делать в виде класса, в отличие от LR.
4. Написаны тесты к обоим алоритмам и общей части.
5. Предполагалось написать парсеры, выдающие не только заключение о выводимости, но и дерево разбора. За неимением времени это осталось нереализованным, а код был закомментирован, чтобы избежать его учёта в анализе покрытия кода.

Обратите внимание: использовано английское название ситуаций --- Items --- согласно Ахо-Ульману. Имплементация LR(1) во многом вообще основана на Dragon Book.

#### Структура папки
##### includes
* `./grammars.h`: описание класса Grammar и связанных, а также реализация inline-функций
* `parsing/earley.h`: заголовочный файл для парсера Эрли
* `parsing/lr.h`: заголовочный файл для парсера LR(1)

#### src
* `./debug.cpp`: файл, использовавшийся для дебага. Сейчас искючен и _не может быть собран_, так как деревья вывода исключены из проекта.
* `./grammars.cpp`: общие функции, связанные с грамматиками. Сейчас там только построитель грамматики по описанию.
* `./main_earley.cpp`: точка входа для standalone парсера Эрли
* `parsing/earley.cpp`: реализация парсера Эрли
* `parsing/lr.cpp`: реализация парсера LR(1)

##### tests
* `./earley.cpp`: тесты алгоритма Эрли
* `./grammar.cpp`: тесты класса Grammar и общих функций
* `./lr.cpp`: тесты LR(1)
* `./main.cpp`: точка входа для тестов
* `./tests.h`: общий заголовочный файл

#### Описание грамматик
Описание грамматик должно подчиняться такой структуре:
```
<Список нетерминальных символов без пробелов>
<Список терминальных символов без пробелов>
<Стартовый символ>
<Список правил по одному на строку>
```

Пустые строки не допускаются. Наличие первых трех строк обязательно. Описание правил должно выглядеть так:
```
N->***
```

Здесь N --- какой-либо нетерминал из второй строки, звездочки --- конечная последовательность терминалов и нетерминалов (возможно, пустая, если правило выводит пустую строку). Пробельные символы не допускаются, если они не представляют собой терминал или нетерминал и не указаны в первых двух строках.

Примеры грамматик можно посмотреть в файлах `./grammar_brackets` и `./grammar_arith`.

#### Запуск решений
Приложения для проверки выводимости слова в произвольной грамматике:
* `./build/bin/earley` (алгоритм Эрли)
* `./build/bin/lr` (алгоритм Эрли)

Эти приложения запускаются из командной строки и принимают два обязательных аргумента --- имя файла с грамматикой и разбираемое слово. Пример запуска алгорита Эрли с грамматикой правильных скобочных последовательностей для слова `()()(())`:
```bash
./build/bin/earley grammar_brackets "()()(())"
```

Вывод состоит из описания грамматики, указания переданного слова и заключении о выводимости на последней строчке: либо "Derived", либо "Not derived".

## Тесты
Написаны тесты с использованием Google Test и сборкой под AddressSanitizer. Покрытие кода на момент написания обоих алгоритмов составило 95.31%. Отчет о покрытии находится в файле `coverage.txt`.

#### Подсчет покрытия
Для подсчета покрытия необходимо запустить программу с тестами, а затем исполнить специальный скрипт:

```bash
./bin/test
./count_coverage.sh ./bin/test
```

Чтобы посмотреть детальный вывод, необходимо установить флаг `show`:
```bash
./bin/test
show=1 ./count_coverage.sh ./bin/test
```